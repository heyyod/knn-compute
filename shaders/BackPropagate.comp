#version 450

#define MaskAndShiftRight(val, mask, shift) ((val & mask) >> shift)

layout (local_size_x = 256) in;

layout(std430, set=0, binding=1) readonly buffer weightsBuffer { float weights[]; };
layout(std430, set=0, binding=2) readonly buffer biasesBuffer { float biases[]; };
layout(std430, set=0, binding=3) buffer productsBuffer { float products[]; };
layout(std430, set=0, binding=4) coherent buffer errorsBuffer { float errors[]; };

layout( push_constant ) uniform constants
{
    uint inErrorsIndex;
    uint inErrorsDim;
    uint weightsIndex;
    uint weightsDim;
    uint biasesIndex;
    uint outErrorsIndex;
    uint outErrorsDim;
    uint batch;
    uint maxBatches;
} pushConstants;

uint mod_u32( uint u32_bas , uint u32_div )
{
    float   flt_res =  mod( float(u32_bas), float(u32_div));
    uint    u32_res = uint( flt_res );
    return( u32_res );
}

void main()
{
    uint p = gl_GlobalInvocationID.x + pushConstants.batch * gl_NumWorkGroups.x * 256;
    if (p >= pushConstants.inErrorsDim * pushConstants.outErrorsDim)
        return;
    
    uint e = pushConstants.inErrorsIndex + mod_u32(p, pushConstants.inErrorsDim);
    uint w = pushConstants.weightsIndex + mod_u32(p, pushConstants.inErrorsDim) * pushConstants.weightsDim + (p / pushConstants.inErrorsDim);
    products[p] = errors[e] * weights[w];
    
    barrier();
    
    if (pushConstants.batch == pushConstants.maxBatches - 1 &&
        gl_GlobalInvocationID.x < pushConstants.outErrorsDim)
    {
        uint b = pushConstants.biasesIndex + gl_GlobalInvocationID.x;
        uint o = pushConstants.outErrorsIndex + gl_GlobalInvocationID.x;
        
        errors[o] = 0.0f;
        
        for (uint i = 0; i < pushConstants.inErrorsDim; i++)
        {
            errors[o] += products[i + gl_GlobalInvocationID.x * pushConstants.inErrorsDim];
        }
        //errors[o] += biases[b];
    }
}