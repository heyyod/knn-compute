#version 450

#define PIXELS_PER_IMAGE 784 //28*28
#define ARRAY_ELEMENTS_PER_IMAGE (PIXELS_PER_IMAGE / 4)

#define MaskAndShiftRight(val, mask, shift) ((val & mask) >> shift)

layout (local_size_x = ARRAY_ELEMENTS_PER_IMAGE) in;

layout(std430, set=0, binding=0) readonly buffer trainBuffer { uint train[]; };
layout(std430, set=0, binding=1) readonly buffer testBuffer { uint test[]; };

// This holds the weight of every perceptron for every input
layout(std430, set=0, binding=2) buffer perceptronWeightBuffer { float weights[]; };

// This hold the product of each input with its corresponding weight
layout(std430, set=0, binding=2) buffer weightedValuesBuffer { float weightedVals[]; };

layout(std430, set=0, binding=3) buffer biasesBuffer { float biases[]; };

// After we calculate all the products, we save their sum here adding the bias at the end
layout(std430, set=0, binding=4) buffer perceptronValuesBuffer { float perceptronVals[]; };

layout( push_constant ) uniform constants
{
    uint trainId;
    uint testId;
    uint layerId;
} pushConstants;

void main()
{
    uint iTrain = pushConstants.trainId * ARRAY_ELEMENTS_PER_IMAGE;
    uint iPerceptron = gl_GlobalInvocationID.x / ARRAY_ELEMENTS_PER_IMAGE;
    uint iWeightedVal = PIXELS_PER_IMAGE * iPerceptron;
    
    uint trainPixels = train[iTrain];
    uint trainPixel0 = MaskAndShiftRight(trainPixels, 0x000000FF, 0);
    uint trainPixel1 = MaskAndShiftRight(trainPixels, 0x0000FF00, 8);
    uint trainPixel2 = MaskAndShiftRight(trainPixels, 0x00FF0000, 16);
    uint trainPixel3 = MaskAndShiftRight(trainPixels, 0xFF000000, 24);
}